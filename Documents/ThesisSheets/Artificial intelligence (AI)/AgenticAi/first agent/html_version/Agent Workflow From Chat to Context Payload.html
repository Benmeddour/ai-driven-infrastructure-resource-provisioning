<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Workflow: From Chat to Context Payload</title>
<style>
body {
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
line-height: 1.6;
color: #34495e;
max-width: 950px;
margin: 20px auto;
padding: 0 20px;
background-color: #f8f9fa;
}
h1,
    h2,
    h3 {
        color: #2c3e50;
        border-bottom: 2px solid #ecf0f1;
        padding-bottom: 10px;
        margin-top: 40px;
    }
    
    h1 {
        text-align: center;
        border-bottom: 3px solid #3498db;
        font-size: 2.5em;
    }
    
    h2 {
        font-size: 1.8em;
        display: flex;
        align-items: center;
    }
    
    h2 .step-number {
        background-color: #3498db;
        color: white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2em;
        font-weight: bold;
        margin-right: 20px;
        flex-shrink: 0;
    }
    
    .introduction {
        background-color: #ebf5fb;
        border: 1px solid #aed6f1;
        padding: 25px;
        border-radius: 8px;
        margin-bottom: 40px;
        font-size: 1.1em;
    }
    
    .workflow-step {
        background-color: #ffffff;
        border: 1px solid #e5e7e9;
        border-left: 5px solid #3498db;
        padding: 20px 25px;
        margin-top: 25px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    
    .arrow-down {
        text-align: center;
        font-size: 2.5em;
        color: #bdc3c7;
        margin: 20px 0;
    }
    
    code {
        background-color: #ecf0f1;
        padding: 4px 7px;
        border-radius: 4px;
        font-family: "Courier New", Courier, monospace;
        color: #c0392b;
        font-size: 0.95em;
    }
    
    pre {
        background-color: #2c3e50;
        color: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-size: 0.9em;
    }
    
    pre .comment {
        color: #7f8c8d;
        font-style: italic;
    }
    
    .user-input {
        margin-top: 15px;
        padding: 15px;
        border-radius: 5px;
        background-color: #e8f6f3;
        border-left: 4px solid #1abc9c;
        font-style: italic;
    }
    
    .agent-response {
        margin-top: 15px;
        padding: 15px;
        border-radius: 5px;
        background-color: #fdedec;
        border-left: 4px solid #e74c3c;
        font-style: italic;
    }
    
    strong {
        color: #2980b9;
    }
</style>
</head>
<body>
<h1>Agent Workflow: From Chat to Context Payload</h1>

<div class="introduction">
    <p>This document illustrates the complete, end-to-end workflow of the <strong>Chat Validator and Data Collector Agent</strong>. The agent's mission is to act as an intelligent gateway, transforming a user's natural language request into a comprehensive, structured, and machine-readable JSON payload. This payload serves as the definitive context for all subsequent decision-making and execution agents.</p>
</div>

<!-- Step 1 -->
<div class="workflow-step">
    <h2><span class="step-number">1</span>User Request & Conversational Validation</h2>
    <p>The entire process is initiated by a natural language request from a user. The agent does not expect rigid commands; it is designed to understand and parse conversational text.</p>
    <div class="user-input">
        "Please deploy our new user-auth-service to K8s. The repo is at https://github.com/my-org/user-auth-service and the image is my-registry/user-auth:v1.2"
    </div>
    <p>The agent's first task is to validate the request. Using the logic from <strong>Input Validation</strong>, it performs several checks:</p>
    <ul>
        <li><strong>Intent Check:</strong> Confirms the user wants to provision a resource (e.g., using keywords like "deploy", "create").</li>
        <li><strong>Platform Identification:</strong> Uses a multi-tiered logic (explicit keywords, technical artifacts, architectural context) to determine the target is <strong>Kubernetes</strong>. In this case, the keyword "K8s" and the presence of a "container image" are definitive clues.</li>
        <li><strong>Entity Extraction:</strong> It parses the message for required parameters. It finds the <code>application_name</code>, <code>repository_url</code>, and <code>container_image</code>.</li>
        <li><strong>Clarification Dialogue:</strong> The agent recognizes that a required parameter, the <code>container_port</code>, is missing. It will not proceed but instead will ask a targeted question to complete the request.</li>
    </ul>
    <div class="agent-response">
        "I'm ready to set up the 'user-auth-service' on Kubernetes. What is the <strong>container port</strong> that the application listens on?"
    </div>
</div>

<div class="arrow-down">↓</div>

<!-- Step 2 -->
<div class="workflow-step">
    <h2><span class="step-number">2</span>Gather Infrastructure State</h2>
    <p>Once the user provides the missing information (e.g., "it runs on port 3000") and the request is fully validated, the agent's <strong>Core Engine</strong> triggers the appropriate <strong>Infrastructure API Client</strong>. Since the platform was identified as Kubernetes, it uses the <strong>Kubernetes API Client</strong>.</p>
    <p>The agent queries the cluster's API server to gather the "ground truth" data needed for initial provisioning. This includes:</p>
    <ul>
        <li><strong>Node Status & Capacity:</strong> To ensure there are <code>Ready</code> nodes with sufficient <code>allocatable</code> resources.</li>
        <li><strong>Resource Constraints:</strong> To be aware of any <code>ResourceQuotas</code> or <code>LimitRanges</code> that must be respected.</li>
        <li><strong>Available StorageClasses:</strong> To know what options exist for persistent storage if needed.</li>
    </ul>
    <p>This step is critical for grounding the subsequent analysis in the reality of the cluster's current state, as outlined in the <strong>Data Collection Requirements</strong>.</p>
</div>

<div class="arrow-down">↓</div>

<!-- Step 3 -->
<div class="workflow-step">
    <h2><span class="step-number">3</span>Consolidate & Generate JSON Output</h2>
    <p>This is the final step for the Data Collector agent. The <strong>JSON Formatter & Serializer</strong> component takes all the information gathered from the previous steps and consolidates it into a single, structured object.</p>
    <ol>
        <li>The <strong>original user chat</strong> and the final, <strong>validated parameters</strong> are placed into the <code>request_details</code> object.</li>
        <li>The real-time data from the Kubernetes API is placed into the <code>infrastructure_state</code> object.</li>
        <li>A pointer to the application's code is placed in the <code>application_context</code>.</li>
        <li>A human-readable summary is generated for logging and auditing.</li>
    </ol>
    <p>This process serializes the disparate pieces of information into the strict, predictable format defined by the <strong>Data Contract</strong>.</p>
</div>

<div class="arrow-down">↓</div>

<!-- Step 4 -->
<div class="workflow-step">
    <h2><span class="step-number">4</span>The Final Deliverable: The Context Payload</h2>
    <p>The agent's work culminates in the creation of a single JSON file. This <strong>Context Payload</strong> is the official hand-off to the next agent in the toolchain (e.g., an Analysis & Planning Agent). It contains everything needed for intelligent decision-making, with all ambiguity removed.</p>
    <pre><code>
{
<span class="comment">// 1. From the user chat and validation dialogue.</span>
"request_details": {
"original_chat": "Please deploy our new user-auth-service to K8s. The repo is at https://github.com/my-org/user-auth-service and the image is my-registry/user-auth:v1.2",
"extracted_parameters": {
"application_name": "user-auth-service",
"container_image": "my-registry/user-auth:v1.2",
"container_port": 3000
}
},
"platform_target": "Kubernetes",
<span class="comment">// 2. From the Kubernetes API Client.</span>
"infrastructure_state": {
"nodes": [
{"name": "k8s-worker-1", "status": "Ready", "allocatable_cpu": "3500m", "allocatable_memory": "7Gi"},
{"name": "k8s-worker-2", "status": "Ready", "allocatable_cpu": "3800m", "allocatable_memory": "7Gi"}
],
"resource_quotas": {"hard": {"limits.cpu": "10", "limits.memory": "32Gi"}},
"storage_classes": ["ceph-rbd", "local-path"]
},
<span class="comment">// 3. A pointer to the application source.</span>
"application_context": {
"repository_url": "https://github.com/my-org/user-auth-service"
},
"summary_message": "Validated request to provision 'user-auth-service' on Kubernetes. Context from cluster state and GitHub repository has been collected for analysis."
}
</code></pre>
</div>
</body>
</html>