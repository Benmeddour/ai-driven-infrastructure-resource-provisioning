<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Toolkit: Validation & Data Collection</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            color: #333;
            max-width: 950px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #fdfdfd;
        }
        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #2980b9;
        }
        h2 .subtitle {
            display: block;
            font-size: 0.8em;
            color: #7f8c8d;
            font-weight: normal;
            margin-top: 5px;
        }
        .introduction {
            background-color: #ebf5fb;
            border: 1px solid #aed6f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 40px;
        }
        .tool-card {
            background-color: #f8f9fa;
            border: 1px solid #e5e7e9;
            border-left: 5px solid #3498db;
            padding: 20px;
            margin-top: 20px;
            border-radius: 5px;
        }
        code {
            background-color: #ecf0f1;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
            color: #c0392b;
        }
        ul {
            list-style-type: square;
            padding-left: 20px;
            margin-top: 10px;
        }
        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>

    <h1>Agent Toolkit: Validation & Data Collection</h1>

    <div class="introduction">
        <p>This document describes the tools and mechanisms used by the <strong>Chat Validator and Data Collector Agent</strong>. This agent acts as the intelligent front door for the entire provisioning workflow. It is not responsible for analysis or decision-making.</p>
        <p>Its sole purpose is to execute a three-step process:</p>
        <ol>
            <li><strong>Validate</strong> the user's conversational input to ensure it's a complete and logical request.</li>
            <li><strong>Gather</strong> all essential data from our infrastructure and the user's application repository.</li>
            <li><strong>Format</strong> all collected information into a structured JSON file for the downstream agents.</li>
        </ol>
    </div>

    <h2>Core Mechanisms <span class="subtitle">The Brains of the Operation</span></h2>

    <div class="tool-card">
        <h3>1. Conversational Validation Engine</h3>
        <p>This is not a single tool but the agent's core LLM-driven logic. It parses the user's natural language chat to perform the validation steps outlined in the flowchart. It is responsible for:</p>
        <ul>
            <li><strong>Intent Recognition:</strong> Determining if the user wants to provision a resource.</li>
            <li><strong>Platform Identification:</strong> Using a "Seasoned DevOps" hierarchy of clues (keywords, technical artifacts, context) to identify the target as Proxmox or Kubernetes.</li>
            <li><strong>Entity Extraction:</strong> Pulling out required parameters like VM names, template IDs, or container images from the conversation.</li>
            <li><strong>Clarification Dialogue:</strong> If information is missing, this engine formulates a targeted question to the user instead of failing.</li>
        </ul>
    </div>

    <div class="tool-card">
        <h3>2. Short-Term Conversational Memory</h3>
        <p>To handle multi-turn clarification dialogues, the agent uses short-term memory. This allows it to remember the initial request while it asks follow-up questions. For example, it remembers the user wants to deploy "OLLAMA on Kubernetes" while it asks for the missing container port.</p>
    </div>

    <h2>Data Collection Tools <span class="subtitle">Gathering the Ground Truth</span></h2>

    <div class="tool-card">
        <h3>1. Proxmox & Kubernetes API Clients</h3>
        <p>These are functions that allow the agent to make authenticated API calls to our clusters. Once the platform is identified, the agent uses the appropriate client to "pull state" as shown in the flowchart. This includes fetching:</p>
        <ul>
            <li>Cluster and Node status, capacity, and real-time load.</li>
            <li>Available storage pools (Proxmox) or <code>StorageClasses</code> (Kubernetes).</li>
            <li>A list of existing templates, images, and resource constraints.</li>
        </ul>
    </div>

    <div class="tool-card">
        <h3>2. Git Repository Cloner</h3>
        <p>If a user provides a GitHub repository link, this tool is invoked to clone the repository into a temporary location. This allows the agent to access the source code, which is the most valuable source of information for a new application. It enables the agent to find the <code>Dockerfile</code>, dependency files, and configuration examples.</p>
    </div>
    
    <div class="tool-card">
        <h3>3. Retrieval-Augmented Generation (RAG) for Supplementary Context</h3>
        <p>This is the most sophisticated tool, responsible for understanding the contents of the cloned repository. It uses a <strong>Retrieval-Augmented Generation (RAG)</strong> approach.</p>
        <ul>
            <li><strong>Identify Key Files:</strong> It scans the cloned repository for files like <code>Dockerfile</code>, <code>requirements.txt</code>, <code>package.json</code>, etc.</li>
            <li><strong>Retrieve Relevant Knowledge (The "R" in RAG):</strong> The content of these files is used to query a specialized knowledge base (a vector database) containing information on sizing different tech stacks, the resource implications of certain libraries (e.g., <code>tensorflow</code> vs. <code>fastapi</code>), and common configuration patterns.</li>
            <li><strong>Generate Insight (The "G" in RAG):</strong> The LLM receives both the direct file content (e.g., a list of Python packages) and the retrieved knowledge to generate a rich analysis of the application's likely resource needs and dependencies.</li>
        </ul>
    </div>

    <h2>Final Output Mechanism <span class="subtitle">Packaging the Data</span></h2>

    <div class="tool-card">
        <h3>Structured JSON Formatter</h3>
        <p>This is the final step in the agent's workflow. The LLM is given a strict instruction to take all the validated parameters, the data collected from the API clients, and the context from the Git repo or RAG, and consolidate it all into a single, well-defined JSON object. This ensures the next agent in the system receives a predictable, machine-readable input to begin its analysis and planning work.</p>
    </div>

</body>
</html>

